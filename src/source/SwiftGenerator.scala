/**
  * Copyright 2024 Snap, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
  *    http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */

package djinni

import java.io._
import djinni.ast.Record.DerivingType
import djinni.ast._
import djinni.generatorTools._
import djinni.meta._
import djinni.writer.IndentWriter
import scala.collection.mutable.ListBuffer
import scala.collection.mutable.TreeSet
import java.util.regex.Pattern
import java.util.regex.Matcher

class SwiftGenerator(spec: Spec) extends Generator(spec) {

  val marshal = new SwiftMarshal(spec)

  def writeSwiftFile(ident: String, origin: String, refs: Iterable[String], f: IndentWriter => Unit) {
    createFile(spec.swiftOutFolder.get, idSwift.ty(ident) + ".swift", (w: IndentWriter) => {
      w.wl("// AUTOGENERATED FILE - DO NOT MODIFY!")
      w.wl("// This file was generated by Djinni from " + origin)
      w.wl
      f(w)
    })
  }
  def writeSwiftPrivateFile(ident: String, origin: String, refs: Iterable[String], f: IndentWriter => Unit) {
    createFile(spec.swiftOutFolder.get, idSwift.ty(ident) + "+Private.swift", (w: IndentWriter) => {
      w.wl("// AUTOGENERATED FILE - DO NOT MODIFY!")
      w.wl("// This file was generated by Djinni from " + origin)
      w.wl
      if (refs.nonEmpty) {
        refs.foreach(s => w.wl(s"import $s"))
        w.wl
      }
      f(w)
    })
  }

  override def generateEnum(origin: String, ident: Ident, doc: Doc, e: Enum) {
    writeSwiftFile(ident, origin, List[String](), w => {
      w.w(s"public enum ${marshal.typename(ident, e)}: Int32").braced {
        writeEnumOptionNone(w, e, idSwift.enum, "=", "case ", "")
        writeEnumOptions(w, e, idSwift.enum, "=", "case ", "")
        writeEnumOptionAll(w, e, idSwift.enum, "=", "case ", "")
      }
    })
    writeSwiftPrivateFile(ident, origin, List[String]("DjinniSupport", spec.swiftModule), w => {
      w.wl(s"typealias ${marshal.typename(ident, e)}Marshaller = DjinniSupport.EnumMarshaller<${marshal.typename(ident, e)}>")
    })
  }

  // return the base type if tm is optional otherwise None
  private def optionalBase(tm: MExpr) : Option[MExpr] = {
    tm.base match {
      case MOptional => Some(tm.args.head)
      case _ => None
    }
  }

  override def generateRecord(origin: String, ident: Ident, doc: Doc, params: Seq[TypeParam], r: Record) {
    writeSwiftFile(ident, origin, List[String](), w => {
      writeDoc(w, doc)
      w.w(s"public struct ${marshal.typename(ident, r)}").braced {
        for (f <- r.fields) {
          writeDoc(w, f.doc)
          w.wl(s"public var ${idSwift.field(f.ident)}: ${marshal.fieldType(f.ty)}")
        }
        val initParams = r.fields.map(f => s"${idSwift.field(f.ident)}: ${marshal.fieldType(f.ty)}").mkString(", ")
        w.wl
        w.wl(s"public init(${initParams})").braced {
          for (f <- r.fields) {
            w.wl(s"self.${idSwift.field(f.ident)} = ${idSwift.field(f.ident)}")
          }
        }
      }
    })
    writeSwiftPrivateFile(ident, origin, List[String]("DjinniSupport", spec.swiftxxBaseLibModule, spec.swiftModule), w => {
      val t = marshal.typename(ident, r)
      w.w(s"enum ${t}Marshaller: DjinniSupport.Marshaller").braced {
        w.wl(s"typealias SwiftType = $t")
        w.w("static func fromCpp(_ c: djinni.swift.AnyValue) -> SwiftType").braced {
          w.wl("return withUnsafePointer(to: c) { p in").nested {
            for ((f, i) <- r.fields.view.zipWithIndex) {
              val swiftExp = s"djinni.swift.getMember(p, $i)"
              w.wl(s"let ${idSwift.field(f.ident)} = ${marshal.fromCpp(f.ty, swiftExp)}")
            }
            val members = r.fields.map(f => s"${idSwift.field(f.ident)}: ${idSwift.field(f.ident)}").mkString(", ")
            w.wl(s"return SwiftType(${members})")
          }
          w.wl("}")
        }
        w.w("static func toCpp(_ s: SwiftType) -> djinni.swift.AnyValue").braced {
          w.wl("var ret = djinni.swift.makeCompositeValue()")
          for (f <- r.fields) {
            val swiftExpr = s"s.${idSwift.field(f.ident)}"
            w.wl(s"djinni.swift.addMember(&ret, ${marshal.toCpp(f.ty,swiftExpr )})")
          }
          w.wl("return ret")
        }
      }
    })
  }
  override def generateInterface(origin: String, ident: Ident, doc: Doc, typeParams: Seq[TypeParam], i: Interface) {
    writeSwiftFile(ident, origin, List[String](), w => {
      writeDoc(w, doc)
      w.w(s"public protocol ${marshal.typename(ident, i)}: AnyObject").braced {
        for (m <- i.methods.filter(!_.static)) {
          writeMethodDoc(w, m, idSwift.local)
          w.w(s"func ${idSwift.method(m.ident)}(")
          w.w(m.params.map(p => s"${idSwift.local(p.ident)}: ${marshal.paramType(p.ty)}").mkString(", "))
          w.wl(s") -> ${marshal.returnType(m.ret)}")
        }
      }
    })
    writeSwiftPrivateFile(ident, origin, List[String]("DjinniSupport", spec.swiftxxBaseLibModule, spec.swiftModule, spec.swiftModule + "Cxx"), w => {
      writeDoc(w, doc)
      // Define CppProxy class if interface is implemented in C++
      if (i.ext.cpp) {
        w.w(s"final class CppProxy: DjinniSupport.CppProxy, ${marshal.typename(ident, i)}").braced {
          for (m <- i.methods.filter(!_.static)) {
            w.w(s"func ${idSwift.method(m.ident)}(")
            w.w(m.params.map(p => s"${idSwift.local(p.ident)}: ${marshal.paramType(p.ty)}").mkString(", "))
            w.w(s") -> ${marshal.returnType(m.ret)}").braced {
              w.wl("var params = djinni.swift.ParameterList()")
              w.wl("params.addValue(inst)")
              for (p <- m.params) {
                w.wl(s"params.addValue(${marshal.toCpp(p.ty, p.ident)})")
              }
              val call = s"${spec.swiftxxNamespace}.${marshal.typename(ident, i)}_${idSwift.method(m.ident)}(&params)"
              if (m.ret.isEmpty) {
                w.wl(call)
              } else {
                w.wl(s"return ${marshal.fromCpp(m.ret.get, call)}")
              }
            }
          }
        }
      }
      // Define the vtbl for protocol wrapper if interface is implemented in Swift
      val swiftProxyClassName = s"${marshal.typename(ident, i)}SwiftProxy"
      val swiftProxyVtbl = s"${idSwift.local(ident)}Methods"
      if (i.ext.swift) {
        w.wl(s"let $swiftProxyVtbl: Vtbl<${marshal.typename(ident, i)}> = [").nested {
          for (m <- i.methods.filter(!_.static)) {
            w.wl("{ inst, params, ret in").nested {
              for ((p, i) <- m.params.view.zipWithIndex) {
                val pi = s"djinni.swift.getMember(params, $i)"
                w.wl(s"let _${idSwift.local(p.ident)} = ${marshal.fromCpp(p.ty, pi)}")
              }
              val args = m.params.map(p => s"${idSwift.local(p.ident)}: _${idSwift.local(p.ident)}").mkString(", ")
              val call = s"inst.${idSwift.method(m.ident)}(${args})"
              if (m.ret.isEmpty) {
                w.wl(call)
              } else {
                w.wl(s"djinni.swift.setReturnValue(ret, ${marshal.toCpp(m.ret.get, call)})")
              }
            }
            w.wl("},")
          }
        }
        w.wl("]")
        w.wl
      }
      // Define the marshaller
      w.w(s"enum ${marshal.typename(ident, i)}Marshaller: DjinniSupport.Marshaller").braced {
        w.wl(s"typealias SwiftType = ${marshal.typename(ident, i)}")
        w.w("static func fromCpp(_ c: djinni.swift.AnyValue) -> SwiftType").braced {
          val newProxyBlock = if (i.ext.cpp) {"{ CppProxy(c) }"} else {"{ fatalError(\"n/a\") }"}
          w.wl(s"return cppInterfaceToSwift(c, ${newProxyBlock})")
        }
        w.w("static func toCpp(_ s: SwiftType) -> djinni.swift.AnyValue").braced {
          val newProxyBlock = if (i.ext.swift) {s"{ ${spec.swiftxxNamespace}.$swiftProxyClassName.make(ctxPtr(s, ${swiftProxyVtbl}), dispatcherProtocalCall)}"} else {"{ fatalError(\"n/a\") }"}
          w.wl(s"return swiftInterfaceToCpp(s, ${newProxyBlock})")
        }
      }
      // Define static method stubs
      val staticMethods = i.methods.filter(_.static)
      if (!staticMethods.isEmpty) {
        w.w(s"public class ${marshal.typename(ident, i)}_statics").braced {
          for (m <- staticMethods) {
            w.w(s"static func ${idSwift.method(m.ident)}(")
            w.w(m.params.map(p => s"${idSwift.local(p.ident)}: ${marshal.paramType(p.ty)}").mkString(", "))
            w.w(s") -> ${marshal.returnType(m.ret)}").braced {
              w.wl("var params = djinni.swift.ParameterList()")
              for (p <- m.params) {
                w.wl(s"params.addValue(${marshal.toCpp(p.ty, p.ident)})")
              }
              val call = s"${spec.swiftxxNamespace}.${marshal.typename(ident, i)}_${idSwift.method(m.ident)}(&params)"
              if (m.ret.isEmpty) {
                w.wl(call)
              } else {
                w.wl(s"return ${marshal.fromCpp(m.ret.get, call)}")
              }
            }
          }
        }
      }
    })
  }
}
